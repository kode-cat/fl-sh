<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Robust P2P File Sharing with PeerJS & Tailwind</title>
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* New terminal-like log styles */
      .logs-container {
        font-family: 'Courier New', Courier, monospace;
        background-color: #1a202c; /* Gray-900 */
        border: 1px solid #4a5568; /* Gray-700 */
        color: #48bb78; /* Green-400 */
        padding: 0.75rem;
        border-radius: 0.5rem;
        max-height: 200px;
        overflow-y: auto;
      }
      .log-entry {
        display: flex;
        align-items: flex-start;
        line-height: 1.4;
      }
      .log-entry .marker {
        color: #f6ad55; /* Orange-300 */
        margin-right: 0.5rem;
      }
      .log-entry.info .message {
        color: #a0aec0; /* Gray-400 */
      }
      .log-entry.success .message {
        color: #48bb78; /* Green-400 */
      }
      .log-entry.error .message {
        color: #f56565; /* Red-400 */
      }
      .log-entry.system .message {
        color: #63b3ed; /* Blue-400 */
      }
      .log-entry a {
        color: #667eea; /* Indigo-500 */
        text-decoration: underline;
      }
      .log-entry a:hover {
        color: #4c51bf; /* Indigo-700 */
      }
      /* Modal styles */
      .modal {
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.75);
        display: flex;
        justify-content: center;
        align-items: center;
        transition: opacity 0.3s ease;
      }
      .modal-content {
        background-color: #ffffff;
        padding: 2rem;
        border-radius: 0.75rem;
        box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        max-width: 400px;
        width: 100%;
        animation: fadeIn 0.5s ease-out;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .hidden {
        display: none;
      }
      [id="mainContent"].is-ready {
        display: block;
      }
      /* Loading spinner */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-top: 4px solid #63b3ed;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body class="bg-gray-50 min-h-screen flex items-center justify-center p-6">
    <div id="idModal" class="modal">
      <div class="modal-content text-center">
        <h3 class="text-2xl font-bold text-gray-800 mb-4">Enter Your Peer ID</h3>
        <p class="text-gray-600 mb-6">Choose a unique ID to connect with others. You can also generate a random one.</p>
        <input type="text" id="uidInput" placeholder="Enter a unique ID (e.g., JohnDoe123)"
               class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400 font-mono text-sm mb-3" />
        <div id="uidValidationFeedback" class="text-red-500 text-sm h-5 mb-3"></div>
        <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
          <button id="randomUidBtn" class="w-full sm:w-1/2 bg-gray-200 text-gray-700 font-bold py-3 rounded-lg shadow-sm hover:bg-gray-300 transition-colors duration-200">
            Generate Random ID
          </button>
          <button id="submitUidBtn" class="w-full sm:w-1/2 bg-indigo-600 text-white font-bold py-3 rounded-lg shadow-md hover:bg-indigo-700 transition-colors duration-200">
            Start Sharing
          </button>
        </div>
      </div>
    </div>
    <div id="mainContent" class="bg-white rounded-lg shadow-2xl max-w-md w-full p-6 hidden">
      <h2 class="text-center text-3xl font-bold text-indigo-700 mb-6">P2P File Sharing</h2>
      <div class="relative mb-5 group">
        <label class="block mb-1 font-semibold text-gray-700">Your Peer ID</label>
        <div id="myIdContainer" class="flex items-center space-x-2">
          <div id="myId" class="flex-1 select-all bg-gray-100 p-3 rounded text-indigo-700 font-mono text-sm break-all group-hover:bg-gray-200 transition-colors duration-200"></div>
          <button id="copyBtn" class="p-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition" title="Copy ID">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path d="M8 2a2 2 0 00-2 2v2a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V8a2 2 0 00-2-2h-2V4a2 2 0 00-2-2H8z" />
              <path d="M10 8h2v2h2v2h-2v2h-2v-2h-2V10h2V8z" />
            </svg>
          </button>
        </div>
        <span id="copyFeedback" class="absolute -bottom-6 left-0 text-xs text-green-600 opacity-0 transition-opacity duration-300">Copied!</span>
      </div>
      <div class="mt-5">
        <label for="connectToId" class="block mb-1 font-semibold text-gray-700">Connect to Peer ID</label>
        <input type="text" id="connectToId" placeholder="Enter peer ID"
               class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400 font-mono text-sm" />
        <div class="mt-3 flex space-x-2">
            <input type="password" id="passwordInput" placeholder="Optional password"
                   class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-400 text-sm" />
            <button id="connectBtn"
                    class="w-2/5 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg shadow-md transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
              Connect
            </button>
        </div>
      </div>
      <div id="connectionStatus"
           class="mt-4 text-center font-semibold text-gray-500 min-h-[1.5rem] transition-colors duration-200"></div>
      <div id="fileTransferSection" class="mt-6 hidden">
        <label class="block mb-1 font-semibold text-gray-700">Select File(s) to Send</label>
        <label class="block w-full text-sm text-gray-500 bg-white border border-gray-300 rounded-lg cursor-pointer hover:bg-gray-100 transition-colors duration-200">
            <input type="file" id="fileInput" multiple class="hidden" />
            <span class="p-3 block text-center">Choose file(s)</span>
        </label>
      </div>
      <div id="logsContainer" class="logs-container">
      </div>
    </div>
    <script>
    const idModal = document.getElementById("idModal");
    const uidInput = document.getElementById("uidInput");
    const randomUidBtn = document.getElementById("randomUidBtn");
    const submitUidBtn = document.getElementById("submitUidBtn");
    const uidValidationFeedback = document.getElementById("uidValidationFeedback");
    const mainContent = document.getElementById("mainContent");
    const myIdElem = document.getElementById("myId");
    const connectToIdElem = document.getElementById("connectToId");
    const connectBtn = document.getElementById("connectBtn");
    const passwordInput = document.getElementById("passwordInput");
    const copyBtn = document.getElementById("copyBtn");
    const copyFeedback = document.getElementById("copyFeedback");
    const connectionStatus = document.getElementById("connectionStatus");
    const fileInput = document.getElementById("fileInput");
    const fileTransferSection = document.getElementById("fileTransferSection");
    const logsContainer = document.getElementById("logsContainer");
    let peer;
    let connections = new Map();
    const sentFiles = new Map(); // Stores file data and hashes
    const randomNames = [
        "Aurora", "Jupiter", "Orion", "Celeste", "Nova", "Leo",
        "Aether", "Caelum", "Vega", "Sirius", "Phoenix", "Lyra",
        "Apollo", "Cosmos", "Solstice", "Helios", "Galactic"
    ];

    // Function to calculate SHA-256 hash of a file
    async function calculateFileHash(arrayBuffer) {
      const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      return hashHex;
    }

    function getRandomId() {
        const adjective = randomNames[Math.floor(Math.random() * randomNames.length)];
        const number = Math.floor(Math.random() * 1000);
        return `${adjective}${number}`;
    }
    function validateUid(id) {
        if (!id) {
            return "ID cannot be empty.";
        }
        if (id.length < 3 || id.length > 20) {
            return "ID must be between 3 and 20 characters.";
        }
        if (!/^[a-zA-Z0-9]+$/.test(id)) {
            return "ID can only contain letters and numbers.";
        }
        return ""; // Empty string means valid
    }
    async function sha256(str) {
        const textEncoder = new TextEncoder();
        const data = textEncoder.encode(str);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    }
    function log(message, type = 'info', sender = 'system') {
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        // Use safer DOM methods to avoid issues with special characters in message
        const markerSpan = document.createElement('span');
        markerSpan.className = 'marker';
        markerSpan.textContent = '>>>';

        const messageSpan = document.createElement('span');
        messageSpan.className = 'message';
        messageSpan.textContent = `[${time}] ${message}`; // textContent handles special chars

        entry.appendChild(markerSpan);
        entry.appendChild(messageSpan);
        logsContainer.appendChild(entry);
        logsContainer.scrollTop = logsContainer.scrollHeight;
    }
    function createPeer(name) {
        if (peer) {
            peer.destroy();
        }
        log(`Attempting to create peer with ID: ${name}...`, 'info');
        peer = new Peer(name, { secure: true });
        peer.on("open", id => {
            myIdElem.textContent = id;
            connectionStatus.textContent = "Ready to connect";
            log(`Peer created with ID: ${id}.`, 'success');
        });
        peer.on("connection", (conn) => {
            handleIncomingConnection(conn);
        });
        peer.on('disconnected', () => {
            log('Peer connection to server lost. Reconnecting...', 'error');
            setTimeout(() => peer.reconnect(), 5000);
        });
        peer.on('error', (err) => {
            if (err.type === 'unavailable-id') {
                uidValidationFeedback.textContent = `The ID "${name}" is unavailable. Please try a different one.`;
                idModal.classList.remove('hidden');
                mainContent.classList.add('hidden');
                log('Peer creation cancelled.', 'error');
            } else if (err.type === 'peer-unavailable') {
                log('The peer ID you tried to connect to does not exist.', 'error');
            } else {
                log(`Peer error: ${err.type}`, 'error');
            }
        });
    }
    function handleIncomingConnection(conn) {
        if (connections.has(conn.peer)) {
            log(`Connection already exists with peer ${conn.peer}. Rejecting new connection.`, 'error');
            conn.close();
            return;
        }
        let passwordTimeout;
        const passwordRequestElem = document.createElement('div');
        passwordRequestElem.className = 'log-entry system flex items-center flex-wrap gap-2 text-white bg-gray-800 p-2 rounded mt-2';
        // Safer construction of innerHTML
        const markerSpan = document.createElement('span');
        markerSpan.className = 'marker';
        markerSpan.textContent = '>>>';
        const messageSpan = document.createElement('span');
        messageSpan.textContent = `Incoming connection from ${conn.peer}. Enter password:`;
        const inputElem = document.createElement('input');
        inputElem.type = 'password';
        inputElem.placeholder = 'Password';
        inputElem.className = 'flex-1 p-1 rounded bg-gray-900 text-green-400 border border-gray-600 focus:outline-none focus:ring-1 focus:ring-indigo-400 min-w-[100px]';
        const buttonElem = document.createElement('button');
        buttonElem.className = 'bg-indigo-600 hover:bg-indigo-700 text-white p-1 rounded min-w-[60px] transition-colors duration-200';
        buttonElem.textContent = 'Verify';

        passwordRequestElem.appendChild(markerSpan);
        passwordRequestElem.appendChild(messageSpan);
        passwordRequestElem.appendChild(inputElem);
        passwordRequestElem.appendChild(buttonElem);

        logsContainer.appendChild(passwordRequestElem);
        logsContainer.scrollTop = logsContainer.scrollHeight;
        const passwordInputElem = passwordRequestElem.querySelector('input');
        const verifyBtn = passwordRequestElem.querySelector('button');
        passwordTimeout = setTimeout(() => {
            log(`Connection request from ${conn.peer} timed out.`, 'error');
            conn.send({ type: 'auth-response', payload: { success: false } });
            conn.close();
            passwordRequestElem.remove();
        }, 5 * 60 * 1000); // 5 minutes
        conn.once('data', async (data) => {
            if (data.type === 'auth') {
                verifyBtn.onclick = async () => {
                    clearTimeout(passwordTimeout);
                    const enteredPasswordHash = await sha256(passwordInputElem.value || '');
                    if (enteredPasswordHash === data.payload.passwordHash) {
                        log(`${conn.peer} accepted password. Establishing connection.`, 'success'); // Kept on one line
                        conn.send({ type: 'auth-response', payload: { success: true } });
                        connections.set(conn.peer, conn);
                        setupConnection(conn, data.payload.sentFiles);
                        passwordRequestElem.remove();
                    } else {
                        log(`${conn.peer} denied entered password. Rejecting connection.`, 'error'); // Kept on one line
                        conn.send({ type: 'auth-response', payload: { success: false } });
                        setTimeout(() => conn.close(), 500);
                        passwordRequestElem.remove();
                    }
                };
            } else {
                log(`First message from ${conn.peer} was not an authentication request. Closing connection.`, 'error');
                conn.close();
                passwordRequestElem.remove();
                clearTimeout(passwordTimeout);
            }
        });
    }
    function setupConnection(conn, remoteSentFiles = []) {
        const statusText = Array.from(connections.keys()).join(', ');
        connectionStatus.textContent = `Connected to: ${statusText}`;
        fileTransferSection.classList.remove("hidden");
        log(`Connection established with: ${conn.peer}`, 'success');
        if (remoteSentFiles.length > 0) {
            log(`Checking for unsent files from ${conn.peer}...`, 'system');
            conn.send({ type: 'check-files', payload: { myFiles: Array.from(sentFiles.keys()) } });
        }
        conn.on("data", async (data) => {
            if (data.type === 'file') {
                // Calculate hash of received file data
                const receivedHash = await calculateFileHash(data.payload.data);
                // Store received file with its hash
                const fileWithHash = {
                    ...data.payload,
                    hash: receivedHash
                };
                // Verify integrity
                if (data.payload.hash && data.payload.hash !== receivedHash) {
                    log(`File integrity check failed for "${data.payload.filename}" from ${conn.peer}. Expected: ${data.payload.hash.substring(0, 8)}..., Received: ${receivedHash.substring(0, 8)}...`, 'error');
                    // Optionally reject or warn about corrupted file
                } else {
                    receiveFile(fileWithHash, conn.peer);
                }
            } else if (data.type === 'auth-response') {
                if (!data.payload.success) {
                    log(`Authentication failed with ${conn.peer}. Closing connection.`, 'error');
                    conn.close();
                    connections.delete(conn.peer);
                }
            } else if (data.type === 'check-files') {
                const myMissingFiles = Array.from(sentFiles.keys()).filter(file => !data.payload.myFiles.includes(file));
                if (myMissingFiles.length > 0) {
                    const resendPrompt = document.createElement('div');
                    resendPrompt.className = 'log-entry error flex items-center flex-wrap gap-2 text-white bg-gray-800 p-2 rounded mt-2';
                    // Safer construction
                    const markerSpan = document.createElement('span');
                    markerSpan.className = 'marker';
                    markerSpan.textContent = '>>>';
                    const messageSpan = document.createElement('span');
                    messageSpan.className = 'text-sm';
                    messageSpan.textContent = `Found ${myMissingFiles.length} unsent file(s) for ${conn.peer}: ${myMissingFiles.join(', ')}.`;
                    const buttonElem = document.createElement('button');
                    buttonElem.className = 'resend-btn bg-red-600 hover:bg-red-700 text-white p-1 rounded text-xs';
                    buttonElem.textContent = 'Resend';

                    resendPrompt.appendChild(markerSpan);
                    resendPrompt.appendChild(messageSpan);
                    resendPrompt.appendChild(buttonElem);

                    logsContainer.appendChild(resendPrompt);
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                    buttonElem.onclick = () => {
                        myMissingFiles.forEach(fileName => {
                            const fileData = sentFiles.get(fileName);
                            conn.send({ type: 'file', payload: fileData });
                            log(`Resent file: "${fileName}" to ${conn.peer}`, 'success');
                        });
                        resendPrompt.remove();
                    };
                }
            }
        });
        conn.on("close", () => {
            connections.delete(conn.peer);
            const statusText = Array.from(connections.keys()).join(', ');
            connectionStatus.textContent = statusText ? `Connected to: ${statusText}` : "Ready to connect";
            if (connections.size === 0) {
                fileTransferSection.classList.add("hidden");
            }
            log(`Connection closed with ${conn.peer}`, 'info');
        });
        conn.on("error", err => {
            log(`Connection error with ${conn.peer}: ${err}`, 'error');
        });
    }
    connectBtn.onclick = async () => {
        const remoteId = connectToIdElem.value.trim();
        const password = passwordInput.value;
        if (!remoteId) {
            log("Please enter a remote peer ID.", 'error');
            return;
        }
        if (remoteId === myIdElem.textContent) {
            log("Cannot connect to yourself. Please enter a different ID.", 'error');
            return;
        }
        if (connections.has(remoteId)) {
            log("Already connected to this peer.", 'error');
            return;
        }
        log(`Attempting connection to ${remoteId}...`, 'info');
        const conn = peer.connect(remoteId);
        conn.on("open", async () => {
            const passwordHash = await sha256(password);
            conn.send({ type: 'auth', payload: { passwordHash, sentFiles: Array.from(sentFiles.keys()) } });
            conn.once('data', (data) => {
                if (data.type === 'auth-response') {
                    if (data.payload.success) {
                        log("Password entered by remote peer is correct. Connection authenticated.", 'success'); // Kept on one line
                        connections.set(remoteId, conn);
                        setupConnection(conn);
                    } else {
                        log("Password entered by remote peer is wrong. Closing connection.", 'error'); // Kept on one line
                        conn.close();
                    }
                }
            });
        });
        conn.on("error", err => {
            log(`Connection error: ${err}`, 'error');
        });
    };
    fileInput.onchange = () => {
        const files = fileInput.files;
        if (files.length === 0) return;
        if (connections.size === 0) {
            log("Please connect to at least one peer before sending files.", 'error');
            fileInput.value = "";
            return;
        }
        for (const file of files) {
            const reader = new FileReader();
            reader.onload = async e => { // Make onload async
                // Calculate hash of the file being sent
                const fileHash = await calculateFileHash(e.target.result);
                const fileData = {
                    filename: file.name,
                    filetype: file.type,
                    data: e.target.result,
                    hash: fileHash // Include hash in the payload
                };
                sentFiles.set(file.name, fileData);

                // Safer construction for the log entry
                const sentFileMarker = document.createElement('div');
                sentFileMarker.className = 'log-entry success';
                const markerSpan = document.createElement('span');
                markerSpan.className = 'marker';
                markerSpan.textContent = '>>>';
                const messageSpan = document.createElement('span');
                messageSpan.className = 'message';
                messageSpan.textContent = `[${new Date().toLocaleTimeString()}] Sent file: ${file.name} (Hash: ${fileHash.substring(0, 8)}...)`; // Use textContent

                sentFileMarker.appendChild(markerSpan);
                sentFileMarker.appendChild(messageSpan);
                logsContainer.appendChild(sentFileMarker);
                logsContainer.scrollTop = logsContainer.scrollHeight;

                connections.forEach(conn => {
                    conn.send({ type: 'file', payload: fileData });
                    log(`Sent file: "${file.name}" to ${conn.peer} (Hash: ${fileHash.substring(0, 8)}...)`, 'success');
                });
            };
            reader.readAsArrayBuffer(file);
        }
        fileInput.value = "";
    };
    function receiveFile(fileObj, fromPeer) {
        const { filename, filetype, data, hash } = fileObj;
        const blob = new Blob([data], { type: filetype });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        link.textContent = filename; // Use textContent for filename

        const receivedFileElem = document.createElement('div');
        receivedFileElem.className = 'log-entry success';
        const markerSpan = document.createElement('span');
        markerSpan.className = 'marker';
        markerSpan.textContent = '>>>';
        const messageSpan = document.createElement('span');
        messageSpan.className = 'message';
        messageSpan.textContent = `[${new Date().toLocaleTimeString()}] Received file from ${fromPeer}: `; // Use textContent

        receivedFileElem.appendChild(markerSpan);
        receivedFileElem.appendChild(messageSpan);
        receivedFileElem.appendChild(link); // Append the link directly

        log(`Received file: "${filename}" from ${fromPeer}${hash ? ` (Hash: ${hash.substring(0, 8)}...)` : ''}`, 'success');
        logsContainer.appendChild(receivedFileElem);
        logsContainer.scrollTop = logsContainer.scrollHeight;
    }
    copyBtn.onclick = () => {
        navigator.clipboard.writeText(myIdElem.textContent).then(() => {
            copyFeedback.classList.add('opacity-100');
            setTimeout(() => {
                copyFeedback.classList.remove('opacity-100');
            }, 1500);
        }).catch(err => {
            log('Failed to copy ID: ' + err, 'error');
        });
    };
    // Modal logic
    randomUidBtn.onclick = () => {
      uidInput.value = getRandomId();
      uidValidationFeedback.textContent = "";
    };
    submitUidBtn.onclick = () => {
      const uid = uidInput.value.trim();
      const validationError = validateUid(uid);
      if (validationError) {
        uidValidationFeedback.textContent = validationError;
      } else {
        idModal.classList.add('hidden');
        mainContent.classList.remove('hidden');
        createPeer(uid);
      }
    };
    </script>
  </body>
</html>
