<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Secure E2EE P2P File Sharing</title>
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Terminal-like log styles */
      .logs-container {
        font-family: 'Courier New', Courier, monospace;
        background-color: #1a202c; /* Gray-900 */
        border: 1px solid #4a5568; /* Gray-700 */
        color: #48bb78; /* Green-400 */
        padding: 0.75rem;
        border-radius: 0.5rem;
        max-height: 200px;
        overflow-y: auto;
      }
      .log-entry {
        display: flex;
        align-items: flex-start;
        line-height: 1.4;
        margin-bottom: 4px;
        word-break: break-all;
      }
      .log-entry .marker {
        color: #f6ad55; /* Orange-300 */
        margin-right: 0.5rem;
        flex-shrink: 0;
      }
      .log-entry.info .message { color: #a0aec0; }
      .log-entry.success .message { color: #48bb78; }
      .log-entry.error .message { color: #f56565; }
      .log-entry.system .message { color: #63b3ed; }
      .log-entry.security .message { color: #d6bcfa; /* Purple-300 */ }
      
      .log-entry a {
        color: #667eea;
        text-decoration: underline;
        margin-left: 5px;
      }
      .log-entry a:hover { color: #4c51bf; }

      /* Modal styles */
      .modal {
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(4px);
        display: flex;
        justify-content: center;
        align-items: center;
        transition: opacity 0.3s ease;
      }
      .modal-content {
        background-color: #ffffff;
        padding: 2rem;
        border-radius: 0.75rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        max-width: 400px;
        width: 90%;
        animation: fadeIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }
      .hidden { display: none; }
      
      /* Security Badge */
      .secure-badge {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        background-color: #d1fae5;
        color: #065f46;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-left: 8px;
      }
    </style>
  </head>
  <body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    
    <!-- ID Generation Modal -->
    <div id="idModal" class="modal">
      <div class="modal-content text-center">
        <div class="mb-4 flex justify-center text-indigo-600">
           <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
           </svg>
        </div>
        <h3 class="text-2xl font-bold text-gray-800 mb-2">Secure Identity</h3>
        <p class="text-gray-600 mb-6 text-sm">Create a unique ID to start your encrypted session.</p>
        
        <input type="text" id="uidInput" placeholder="Enter ID (e.g. Alice)" 
               class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 font-mono text-sm mb-2" />
        
        <div id="uidValidationFeedback" class="text-red-500 text-xs h-4 mb-4 text-left"></div>
        
        <div class="flex flex-col gap-3">
          <button id="submitUidBtn" class="w-full bg-indigo-600 text-white font-bold py-3 rounded-lg shadow hover:bg-indigo-700 transition transform active:scale-95">
            Initialize Secure Session
          </button>
          <button id="randomUidBtn" class="w-full bg-gray-100 text-gray-600 font-semibold py-2 rounded-lg hover:bg-gray-200 transition text-sm">
            Generate Random ID
          </button>
        </div>
      </div>
    </div>

    <!-- Main Application -->
    <div id="mainContent" class="bg-white rounded-xl shadow-2xl max-w-lg w-full p-6 hidden relative overflow-hidden">
      <!-- Header -->
      <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold text-gray-800 flex items-center">
            P2P Transfer
            <span class="secure-badge">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                </svg>
                AES-GCM
            </span>
          </h2>
          <div class="text-xs text-gray-400 font-mono" id="versionId">v2.0</div>
      </div>

      <!-- My ID Section -->
      <div class="relative mb-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
        <label class="block mb-2 text-xs font-bold text-gray-500 uppercase tracking-wide">Your Peer ID</label>
        <div class="flex items-center gap-2">
          <div id="myId" class="flex-1 bg-white border border-gray-300 p-2 rounded text-indigo-700 font-mono text-sm font-bold select-all overflow-hidden text-ellipsis">...</div>
          <button id="copyBtn" class="p-2 bg-white border border-gray-300 text-gray-600 rounded hover:bg-gray-50 transition" title="Copy ID">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
            </svg>
          </button>
        </div>
        <span id="copyFeedback" class="absolute top-2 right-4 text-xs text-green-600 font-bold opacity-0 transition-opacity duration-300">Copied!</span>
      </div>

      <!-- Connection Form -->
      <div class="mb-6">
        <label class="block mb-2 text-xs font-bold text-gray-500 uppercase tracking-wide">Secure Connect</label>
        <div class="grid grid-cols-1 gap-3">
            <input type="text" id="connectToId" placeholder="Peer ID to connect" 
                   class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 font-mono text-sm" />
            
            <div class="flex gap-2">
                <input type="password" id="passwordInput" placeholder="Shared Secret (Password)" 
                       class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-sm" />
                <button id="connectBtn" 
                        class="px-6 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-lg shadow transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                  Connect
                </button>
            </div>
        </div>
        <p class="text-xs text-gray-400 mt-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 inline mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd" />
            </svg>
            Both parties must enter the same password to decrypt data.
        </p>
      </div>

      <!-- Connection Status -->
      <div id="connectionStatus" class="mb-4 text-center text-sm font-semibold text-gray-500 min-h-[1.25rem]"></div>

      <!-- File Transfer -->
      <div id="fileTransferSection" class="mb-6 hidden animate-fade-in-down">
        <label class="block w-full cursor-pointer group">
            <div class="border-2 border-dashed border-indigo-300 rounded-lg p-6 text-center hover:bg-indigo-50 transition bg-indigo-50/30">
                <div class="text-indigo-500 mb-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                </div>
                <span class="text-sm font-medium text-indigo-600 group-hover:text-indigo-700">Click to Encrypt & Send File</span>
                <input type="file" id="fileInput" multiple class="hidden" />
            </div>
        </label>
      </div>

      <!-- Logs -->
      <div class="relative">
          <div class="absolute top-0 right-0 -mt-6">
             <button id="clearLogsBtn" class="text-xs text-gray-400 hover:text-gray-600 underline">Clear</button>
          </div>
          <div id="logsContainer" class="logs-container h-48"></div>
      </div>
    </div>

    <!-- Incoming Connection Modal (Dynamic) -->
    <div id="passwordModal" class="modal hidden">
        <div class="modal-content">
            <div class="flex items-center mb-4 text-indigo-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                </svg>
                <h3 class="text-lg font-bold text-gray-800">Authentication Required</h3>
            </div>
            <p class="text-gray-600 text-sm mb-4">
                Peer <strong id="incomingPeerId" class="text-gray-800"></strong> is requesting a secure connection. Enter the shared password to decrypt the handshake.
            </p>
            <input type="password" id="incomingPasswordInput" placeholder="Enter Shared Password" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-2 focus:ring-indigo-500 focus:outline-none" />
            <div class="flex space-x-3">
                <button id="rejectConnBtn" class="flex-1 bg-red-100 text-red-700 font-semibold py-2 rounded-lg hover:bg-red-200 transition">Reject</button>
                <button id="acceptConnBtn" class="flex-1 bg-indigo-600 text-white font-semibold py-2 rounded-lg hover:bg-indigo-700 transition shadow">Verify & Connect</button>
            </div>
        </div>
    </div>

    <script>
    // --- DOM Elements ---
    const idModal = document.getElementById("idModal");
    const uidInput = document.getElementById("uidInput");
    const randomUidBtn = document.getElementById("randomUidBtn");
    const submitUidBtn = document.getElementById("submitUidBtn");
    const uidValidationFeedback = document.getElementById("uidValidationFeedback");
    
    const mainContent = document.getElementById("mainContent");
    const myIdElem = document.getElementById("myId");
    const connectToIdElem = document.getElementById("connectToId");
    const connectBtn = document.getElementById("connectBtn");
    const passwordInput = document.getElementById("passwordInput");
    const copyBtn = document.getElementById("copyBtn");
    const copyFeedback = document.getElementById("copyFeedback");
    const connectionStatus = document.getElementById("connectionStatus");
    const fileInput = document.getElementById("fileInput");
    const fileTransferSection = document.getElementById("fileTransferSection");
    const logsContainer = document.getElementById("logsContainer");
    const clearLogsBtn = document.getElementById("clearLogsBtn");

    const passwordModal = document.getElementById("passwordModal");
    const incomingPeerIdSpan = document.getElementById("incomingPeerId");
    const incomingPasswordInput = document.getElementById("incomingPasswordInput");
    const acceptConnBtn = document.getElementById("acceptConnBtn");
    const rejectConnBtn = document.getElementById("rejectConnBtn");

    // --- State & Globals ---
    let peer;
    // Map<peerId, { conn: DataConnection, key: CryptoKey }>
    const connections = new Map();
    const sentFiles = new Map(); 

    // Constants for Crypto
    const SALT_LENGTH = 16;
    const IV_LENGTH = 12; // Standard for AES-GCM
    const PBKDF2_ITERATIONS = 100000;
    
    // --- Crypto Functions ---

    /**
     * Generates a cryptographically strong random salt.
     */
    function generateSalt() {
        return window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
    }

    /**
     * Generates a random Initialization Vector (IV).
     */
    function generateIV() {
        return window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
    }

    /**
     * Derives an AES-GCM key from a password and a salt using PBKDF2.
     */
    async function deriveKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey(
            "raw", 
            enc.encode(password), 
            { name: "PBKDF2" }, 
            false, 
            ["deriveKey"]
        );
        
        return window.crypto.subtle.deriveKey(
            {
                name: "PBKDF2",
                salt: salt,
                iterations: PBKDF2_ITERATIONS,
                hash: "SHA-256"
            },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false, // Key is not exportable
            ["encrypt", "decrypt"]
        );
    }

    /**
     * Encrypts data using AES-GCM.
     * Returns object with { iv, encryptedData } (as Arrays/Buffers)
     */
    async function encryptData(key, data) {
        const iv = generateIV();
        const encrypted = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            key,
            data
        );
        return { iv, encrypted };
    }

    /**
     * Decrypts data using AES-GCM.
     * Throws error if decryption fails (wrong key/tampered data).
     */
    async function decryptData(key, iv, encryptedData) {
        return await window.crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv },
            key,
            encryptedData
        );
    }

    /**
     * Converts ArrayBuffer to Base64 (for logging/debugging if needed, though mostly we send binary).
     */
    function ab2str(buf) {
        return String.fromCharCode.apply(null, new Uint16Array(buf));
    }

    // --- Helper Utils ---

    function sanitizeFilename(name) {
        return name.replace(/[^a-zA-Z0-9._-]/g, "_");
    }

    function getRandomId() {
        const adjectives = ["Secure", "Hidden", "Encrypted", "Silent", "Rapid", "Blue", "Red", "Cosmic"];
        const nouns = ["Vault", "Link", "Node", "Key", "Shield", "Falcon", "Ghost", "Nebula"];
        const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];
        return `${rand(adjectives)}${rand(nouns)}${Math.floor(Math.random() * 999)}`;
    }

    function log(message, type = 'info') {
        const time = new Date().toLocaleTimeString();
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        
        const markerSpan = document.createElement('span');
        markerSpan.className = 'marker';
        markerSpan.textContent = type === 'security' ? 'ðŸ”’' : '>';

        const messageSpan = document.createElement('span');
        messageSpan.className = 'message';
        messageSpan.textContent = `[${time}] ${message}`;

        entry.appendChild(markerSpan);
        entry.appendChild(messageSpan);
        logsContainer.appendChild(entry);
        logsContainer.scrollTop = logsContainer.scrollHeight;
    }

    // --- Core Logic ---

    function initPeer(id) {
        if (peer) peer.destroy();
        log(`Initializing secure node: ${id}...`, 'info');
        
        peer = new Peer(id, {
            debug: 1,
            secure: true // Use SSL for signaling
        });

        peer.on("open", (id) => {
            myIdElem.textContent = id;
            log(`Node Active. ID: ${id}`, 'success');
            connectionStatus.textContent = "Waiting for secure handshake...";
        });

        peer.on("connection", (conn) => {
            handleIncomingHandshake(conn);
        });

        peer.on("error", (err) => {
            if (err.type === 'unavailable-id') {
                uidValidationFeedback.textContent = "ID already taken.";
                idModal.classList.remove('hidden');
                mainContent.classList.add('hidden');
            }
            log(`Peer Error: ${err.type}`, 'error');
        });
    }

    // --- Handshake Protocol ---
    // 1. Sender: Connects -> Sends { type: 'handshake-challenge', salt: <salt>, iv: <iv>, payload: <encrypted_magic_string> }
    // 2. Receiver: Prompts Password -> Derives Key(salt) -> Decrypts Payload. 
    //    If payload == "SECURE_P2P_HANDSHAKE", Success.
    // 3. Receiver: Sends { type: 'handshake-ack' }
    // 4. Session Established.

    async function initiateConnection() {
        const remoteId = connectToIdElem.value.trim();
        const password = passwordInput.value;

        if (!remoteId || !password) {
            log("ID and Password are required.", 'error');
            return;
        }
        if (remoteId === myIdElem.textContent) return log("Cannot connect to self.", 'error');

        log(`Connecting to ${remoteId}...`, 'info');
        
        // 1. Derive Key immediately
        const salt = generateSalt();
        const key = await deriveKey(password, salt);
        
        // 2. Prepare Challenge
        const enc = new TextEncoder();
        const challengeData = enc.encode("SECURE_P2P_HANDSHAKE");
        const { iv, encrypted } = await encryptData(key, challengeData);

        const conn = peer.connect(remoteId);

        conn.on('open', () => {
            log(`Signaling linked. Sending Auth Challenge...`, 'security');
            conn.send({
                type: 'handshake-challenge',
                salt: salt,
                iv: iv,
                payload: encrypted
            });
        });

        // Wait for ACK
        conn.on('data', (data) => {
            if (data.type === 'handshake-ack') {
                log(`Authentication Successful! Secure Tunnel Established.`, 'success');
                connections.set(remoteId, { conn, key });
                updateStatus();
                fileTransferSection.classList.remove('hidden');
            } else if (data.type === 'auth-failed') {
                log(`Authentication Failed: Remote peer rejected password.`, 'error');
                conn.close();
            } else if (data.type === 'file-transfer') {
                 // Should check if authorized first, but handleData checks map
                 handleSecureData(remoteId, data);
            }
        });

        conn.on('close', () => cleanupConnection(remoteId));
    }

    function handleIncomingHandshake(conn) {
        log(`Incoming connection request from ${conn.peer}...`, 'security');
        
        conn.once('data', async (data) => {
            if (data.type === 'handshake-challenge') {
                // Show Modal
                incomingPeerIdSpan.textContent = conn.peer;
                incomingPasswordInput.value = ""; // Clear previous
                passwordModal.classList.remove('hidden');

                // Define handlers specifically for this connection attempt
                const handleAccept = async () => {
                    const password = incomingPasswordInput.value;
                    if(!password) return;

                    passwordModal.classList.add('hidden');
                    log(`Verifying credentials...`, 'info');

                    try {
                        // 1. Derive Key using Sender's Salt
                        const key = await deriveKey(password, data.salt);

                        // 2. Attempt Decrypt
                        const decryptedBuf = await decryptData(key, data.iv, data.payload);
                        const dec = new TextDecoder();
                        const magic = dec.decode(decryptedBuf);

                        if (magic === "SECURE_P2P_HANDSHAKE") {
                            log(`Password verified. Handshake complete.`, 'success');
                            conn.send({ type: 'handshake-ack' });
                            
                            connections.set(conn.peer, { conn, key });
                            updateStatus();
                            fileTransferSection.classList.remove('hidden');
                            
                            // Setup persistent listener
                            conn.on('data', (d) => handleSecureData(conn.peer, d));
                            conn.on('close', () => cleanupConnection(conn.peer));
                        } else {
                            throw new Error("Invalid magic string");
                        }
                    } catch (e) {
                        log(`Decryption failed: Wrong password or tampered data.`, 'error');
                        conn.send({ type: 'auth-failed' });
                        conn.close();
                    }
                };

                const handleReject = () => {
                    passwordModal.classList.add('hidden');
                    conn.close();
                    log(`Connection from ${conn.peer} rejected by user.`, 'error');
                };

                // Bind once
                acceptConnBtn.onclick = handleAccept;
                rejectConnBtn.onclick = handleReject;
            }
        });
    }

    // --- Secure Data Handling ---

    async function handleSecureData(peerId, data) {
        const session = connections.get(peerId);
        if (!session) return;

        if (data.type === 'file-transfer') {
            try {
                log(`Receiving encrypted file chunk from ${peerId}...`, 'info');
                const decryptedContent = await decryptData(session.key, data.iv, data.payload);
                
                // Reconstruct File
                const blob = new Blob([decryptedContent], { type: data.filetype });
                const url = URL.createObjectURL(blob);
                const safeName = sanitizeFilename(data.filename);

                const link = document.createElement("a");
                link.href = url;
                link.download = safeName;
                link.textContent = safeName;

                const entry = document.createElement("div");
                entry.className = "log-entry success";
                entry.innerHTML = `<span class="marker">ðŸ”’</span><span class="message">[Received] </span>`;
                entry.appendChild(link);
                
                logsContainer.appendChild(entry);
                logsContainer.scrollTop = logsContainer.scrollHeight;
                log(`File decrypted successfully.`, 'success');

            } catch (e) {
                console.error(e);
                log(`Failed to decrypt file from ${peerId}. Integrity compromised.`, 'error');
            }
        }
    }

    async function sendFiles() {
        const files = fileInput.files;
        if (files.length === 0) return;
        if (connections.size === 0) return log("No active secure connections.", 'error');

        for (const file of files) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const rawData = e.target.result; // ArrayBuffer

                log(`Encrypting ${file.name} (${file.size} bytes)...`, 'security');

                // Encrypt for each peer (IV must be unique per message)
                for (const [peerId, session] of connections) {
                    try {
                        const { iv, encrypted } = await encryptData(session.key, rawData);
                        
                        session.conn.send({
                            type: 'file-transfer',
                            filename: file.name,
                            filetype: file.type,
                            iv: iv,
                            payload: encrypted
                        });
                        log(`Sent encrypted "${file.name}" to ${peerId}.`, 'success');
                    } catch (err) {
                        log(`Encryption failed for ${peerId}: ${err.message}`, 'error');
                    }
                }
            };
            reader.readAsArrayBuffer(file);
        }
        fileInput.value = ""; // Reset
    }

    // --- UI/System Helpers ---

    function cleanupConnection(peerId) {
        connections.delete(peerId);
        updateStatus();
        log(`Connection with ${peerId} closed.`, 'info');
        if (connections.size === 0) fileTransferSection.classList.add('hidden');
    }

    function updateStatus() {
        const count = connections.size;
        if (count === 0) {
            connectionStatus.textContent = "Not connected";
            connectionStatus.className = "mb-4 text-center text-sm font-semibold text-gray-500";
        } else {
            const names = Array.from(connections.keys()).join(', ');
            connectionStatus.textContent = `Securely Connected: ${names}`;
            connectionStatus.className = "mb-4 text-center text-sm font-bold text-green-600";
        }
    }

    // Event Listeners
    randomUidBtn.onclick = () => { uidInput.value = getRandomId(); uidValidationFeedback.textContent = ""; };
    submitUidBtn.onclick = () => {
        const uid = uidInput.value.trim();
        if (uid.length < 3) return uidValidationFeedback.textContent = "ID too short.";
        if (!/^[a-zA-Z0-9]+$/.test(uid)) return uidValidationFeedback.textContent = "Alphanumeric only.";
        
        idModal.classList.add('hidden');
        mainContent.classList.remove('hidden');
        initPeer(uid);
    };

    connectBtn.onclick = initiateConnection;
    fileInput.onchange = sendFiles;
    
    copyBtn.onclick = () => {
        navigator.clipboard.writeText(myIdElem.textContent);
        copyFeedback.classList.remove('opacity-0');
        setTimeout(() => copyFeedback.classList.add('opacity-0'), 1500);
    };
    
    clearLogsBtn.onclick = () => logsContainer.innerHTML = '';

    </script>
  </body>
</html>
